{"mappings":"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","sources":["src/api.js","src/sections/artists.js","src/lib/formatTimestamp.js","src/sections/player.js","src/lib/JsonStorage.js","src/favorites.js","src/sections/songs.js","src/sections/search_input.js","src/index.js"],"sourcesContent":["// URL de base du serveur\nconst BASE_URL = 'https://webmob-ui-22-spotlified.herokuapp.com'\n\n// Fonction loadJson utilisée à l'interne. Elle s'occupe de charger l'url passée en paramètre et convertir\n// son résultat en json\nasync function loadJson(url) {\n  const response = await fetch(url)\n  const parsedJson = await response.json()\n  return parsedJson\n}\n\n// Retourne une liste d'artistes\nasync function getArtists() {\n  return await loadJson(`${BASE_URL}/api/artists`)\n}\n\n// Retourne la liste des chansons d'un ariste\nasync function getSongsForArtist(id) {\n  return await loadJson(`${BASE_URL}/api/artists/${id}/songs`)\n}\n\n// Retourne un résultat de recherche\nasync function searchSongs(query) {\n  return await loadJson(`${BASE_URL}/api/songs/search/${encodeURIComponent(query)}`)\n}\n\nexport { getArtists, getSongsForArtist, searchSongs }\n","import { getArtists } from '../api'\n\n // On obtient l'élément DOM qui nous servira de template pour un élément de la liste d'artistes\nconst artistListItemTemplate = document.querySelector('#artist-list-item-template')\n\n// Element DOM de la liste à manipuler\nconst artistList =  document.querySelector('.artist-list')\n\n// Génère le HTML nécessaire pour afficher la liste des artistes\nconst renderArtists = async () => {\n  // On vide la liste de ses anciennes informations, pour en ajouter de nouvelles à jour\n  artistList.replaceChildren()\n\n  // On récupère les artistes depuis l'API\n  const artists = await getArtists()\n\n  // On itère sur chacun des artistes récupérés depuis l'API\n  artists.forEach((artist) => {\n    // Créer une copie du template et de son contenu pour avoir un nouvelle élément vierge\n    // que l'on stock dans la variable newArtistItem\n    const newArtistItem = artistListItemTemplate.content.cloneNode(true)\n\n    // On modifie l'url du lien qui se trouve à l'intérieur, pour avoir une URL du style #artists-12\n    newArtistItem.querySelector('a').href = '#artists-' + artist.id\n\n    // On rempli le titre de l'artiste dans ce nouvel élément, en sélectionnant l'élément\n    // artist-list-item-title à l'intérieur (!dans newArtistItem! Pas dans document)\n    newArtistItem.querySelector('.artist-list-item-title').innerHTML = artist.name\n\n    // On modifie le src de l'image qui se trouve à l'intérieur, pour afficher la cover de l'artiste\n    newArtistItem.querySelector('img').src = artist.image_url\n\n    // On l'ajoute à la liste d'artistes\n    artistList.append(newArtistItem)\n  })\n}\n\nexport default renderArtists\n","export default function formatTimestamp(timestamp) {\n  timestamp = parseInt(timestamp, 10)\n  let hours   = Math.floor(timestamp / 3600)\n  let minutes = Math.floor((timestamp - (hours * 3600)) / 60)\n  let seconds = timestamp - (hours * 3600) - (minutes * 60)\n\n  if (minutes < 10) minutes = \"0\" + minutes\n  if (seconds < 10) seconds = \"0\" + seconds\n  return minutes + ':' + seconds\n}\n","import formatTimestamp from '../lib/formatTimestamp'\n\n////////// Constantes des différents tags HTML\n// Tag audio\nconst audioPlayer = document.querySelector('#audio-player')\n\n// Song infos\nconst playerThumbnail = document.querySelector('#player-thumbnail-image')\nconst playerSongTitle = document.querySelector('#player-infos-song-title')\nconst playerArtistName = document.querySelector('#player-infos-artist-name')\n\n// Controls\nconst playerPrev = document.querySelector('#player-control-previous')\nconst playerPlay = document.querySelector('#player-control-play')\nconst playerPlayIcon = document.querySelector('#player-control-play .material-icons')\nconst playerNext = document.querySelector('#player-control-next')\n\n// Progress\nconst playerTimeCurrent = document.querySelector('#player-time-current')\nconst playerTimeDuration = document.querySelector('#player-time-duration')\nconst playerProgress = document.querySelector('#player-progress-bar')\n\n// Logo\nconst logo = document.querySelector('#logo')\n\n////////// Logique\n\n// songs contiendra la liste des chansons en cours de lecture, afin de pouvoir se déplacer entre les chansons\nlet songList = []\n// La chanson en cours de lecture\nlet currentSong = null\n\n// Lire une chanson sur laquelle on clique\nconst playSong = (song, songs) => {\n  // On enregistre la chanson en cours de lecture\n  currentSong = song\n\n  // si un tableau est transmis, on le met à jour. Cela nous permet d'utiliser juste playSong(song) à l'interne,\n  // sans devoir le repasser à chaque fois (depuis previous/next, par exemple)\n  if(songs)\n    songList = songs\n\n  // On donne l'url au player et démarre la lecture\n  audioPlayer.src = song.audio_url\n  audioPlayer.play()\n\n  // Remplacement des différentes informations au sein des tags\n  playerSongTitle.innerHTML = song.title\n  playerArtistName.innerHTML = song.artist.name\n  playerThumbnail.src = song.artist.image_url\n}\n\n// Lis la chanson suivante, d'après la chanson en cours\nconst playNextSong = () => {\n  const index = songList.indexOf(currentSong)\n  const newIndex = index + 1\n  // On s'assure qu'on n'arrive jamais en dehors du tableau et on reboucle sur le début\n  if(newIndex < songList.length)\n    playSong(songList[newIndex])\n  else\n    playSong(songList[0])\n}\n\n// Lis la chanson précédente, d'après la chanson en cours\nconst playPreviousSong = () => {\n  const index = songList.indexOf(currentSong)\n  const newIndex = index - 1\n  // On s'assure qu'on n'arrive jamais en dehors du tableau et on reboucle sur la fin\n  if(newIndex >= 0)\n    playSong(songList[newIndex])\n  else\n    playSong(songList[songList.length - 1])\n}\n\n// Met à jour l'icone du bouton play/pause dans le player + anime l'icone de l'app\nconst updateIcon = () => {\n  if(audioPlayer.paused) {\n    playerPlayIcon.innerHTML = 'play_arrow'\n\n    // On arrête d'animer le logo de l'application lorsqu'aucune chanson ne se lit, pour moins de fancyness\n    logo.classList.remove('animated')\n\n  } else {\n    playerPlayIcon.innerHTML = 'pause'\n\n    // On anime le logo de l'application lorsqu'une chanson se lit, pour plus de fancyness\n    logo.classList.add('animated')\n  }\n}\n\n// On écoute le clique sur le bouton play et on transmets l'instruction au player\nplayerPlay.addEventListener('click', () => {\n  if(audioPlayer.paused)\n    audioPlayer.play()\n  else\n    audioPlayer.pause()\n})\n\n// Bouton précédent\nplayerPrev.addEventListener('click', playPreviousSong)\n\n// Bouton suivant\nplayerNext.addEventListener('click', playNextSong)\n\n// Lorsque l'on click sur la barre de progression, on change sa valeur et elle émet donc un événement \"change\" pour\n// avertir de son changement. Comme on a défini la valeur max comme étant la durée totale de la chanson, toute valeur\n// transmise est forcément incluse dans cet interval. On peut alors la passer au player sans problème\nplayerProgress.addEventListener('change', (event) => {\n  audioPlayer.currentTime = event.currentTarget.value\n})\n\n// Lorsque nous faison \".src = \" sur le player, celui-ci va télécharger la chanson en arrière plan et calculer\n// sa longueur. Lorsque c'est fait, il émet un event \"durationchange\" pour nous informer qu'il connait maintenant\n// sa durée (en secondes!) et que l'on peut se servir de cette information\naudioPlayer.addEventListener('durationchange', () => {\n  // On défini la valeur maximum du slider de la chanson comme étant sa durée en secondes\n  playerProgress.max = audioPlayer.duration\n  // On affiche la durée totale, grâce à la fonction de formattage du temps\n  playerTimeDuration.innerText = formatTimestamp(audioPlayer.duration)\n})\n\n// Lorsque la chanson est en cours de lecture, l'événement \"timeupdate\" sera envoyé plusieurs fois par seconde\n// pour avertir de l'avancée dans la lecture. C'est cet événement qui nous permet de bouger la barre de progression\n// au fur et à mesure que la chanson se lit.\naudioPlayer.addEventListener('timeupdate', () => {\n  // On récupère la valeur \"currentTime\" qui est la position dans la chanson au sein du player et on la transmets\n  // à la progress bar comme étant sa valeur. La progress bar a comme valeur minimum 0 et comme valeur max la durée\n  // totale de la chanson. En lui passant le currrentTime, il sera forcément entre le min et le max et le browser\n  // pourra afficher la petite boule au bon endroit\n  playerProgress.value = audioPlayer.currentTime\n  // On affiche la position de lecture, grâce à la fonction de formattage du temps\n  playerTimeCurrent.innerText = formatTimestamp(audioPlayer.currentTime)\n})\n\n// Lorsque le player se met en lecture, il émet un évent \"play\" pour annoncer le début de lecture. Dans ce cas,\n// on change l'icône du bouton play à pause\n//\n// Pourquoi faire ça ici et non dans le \"click\" sur le bouton ? :) Que se passe-t-il si vous utilisez le bouton\n// \"play/pause\" natif qui se trouve sur votre clavier ? Cela va mettre en pause la chanson, mais l'événement \"click\"\n// du bouton play/pause ne sera pas émis, donc icône pas mis à jour, car vous avez utilisez votre clavier et\n// non le bouton.\n// En revanche, lorsque votre OS reçoit le click sur le clavier, il trouve l'application qui émet du son (en l'occ.\n// notre browser) et lui demande d'arrêter. Le browser va chercher quel élément audio lis actuellement de la musique\n// et va faire un \"audioPlayer.pause()\". Les évenements play/pause seront donc transmis et c'est pour cela qu'il est\n// mieux de gérer le changement d'icône ici\naudioPlayer.addEventListener('play', updateIcon)\n\n// Lorsque le player pause la lecture, il émet un évent \"pause\" pour annoncer le pause de lecture. Dans ce cas,\n// on change l'icône du bouton pause à play\n// voir commentaire précédent\naudioPlayer.addEventListener('pause', updateIcon)\n\nexport default playSong\n","/** \n * Class representing a LocalStorage handler, with JSON and storage's name management \n *\n * Licence: GNU General Public License v3.0  \n * Author: Nicolas Chabloz  \n */\nexport default class {\n\n  /**\n   * Create a JsonStorage.\n   * \n   * @param {Object} [options={}] - Options\n   * @param {string} [options.name=\"default\"] - The name of the storage.\n   * @param {boolean} [options.listen=true] - Listen to storage events for data update\n   * @param {boolean} [options.trigger=true] - Trigger an event on \"window\" when data is set, changed or deleted in the storage\n   * @param {boolean} [options.eventName=\"jsonstorage\"] - The event's name to trigger \n   */  \n  constructor(options = {}) {\n    this.options = {\n      name: options.name || \"default\",\n      listen: options.listen || true,\n      trigger: options.trigger || true,\n      eventName: options.eventName || \"jsonstorage\"\n    };\n    this._reloadKeys();\n    // reload keys data when storage change from another tab\n    if (this.options.listen) {\n      window.addEventListener('storage', evt => {\n        if (!evt.key.startsWith(`${this.options.name}_`)) return;\n        this._reloadKeys();\n        if (this.options.trigger) {\n          window.dispatchEvent(new Event(this.options.eventName));\n        }\n      });\n    }\n  }\n\n  /**\n   * Private method\n   */\n  _reloadKeys() {\n    this.storageKeys = Object.keys(localStorage)\n      .filter(key => key.startsWith(`${this.options.name}_`))\n      .reduce((map, key) => map.set(key.substring(`${this.options.name}_`.length), 1), new Map());\n  }\n\n  /**\n   * Returns a new Iterator object that contains an array of [key, value] for each element in the storage\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element in the storage.\n   */\n  keys() {\n    return this.storageKeys.keys();\n  }\n\n  /**\n   * Returns the name of the nth key in the storage\n   * \n   * @param {integer} ind Indice\n   */\n  key(ind) {\n    let keys = [...this.keys()];\n    if (ind < 0 || ind >= keys.length) return null\n    return keys[ind];\n  }\n\n  /**\n   * Returns a new Iterator object that contains the values for each element in the storage.\n   */\n  *values() {\n    for (let k of this.keys()) {\n      yield this.getItem(k);\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains an array of [key, value] for each element in the storage.\n   */\n  *entries() {\n    for (let k of this.keys()) {\n      yield [k, this.getItem(k)];\n    }\n  }\n\n  /**\n   * Calls callback once for each key-value pair present in the storage. The callback is called with the value and the key as parameters.\n   * \n   * @param {function} callback \n   */\n  forEach(callback) {\n    for (let entrie of this) {\n      callback(entrie[1], entrie[0]);\n    }\n  }\n\n  /**\n   * Return an array of [key, value] for each element in the storage.\n   */\n  toArray() {\n    return [...this.entries()];\n  }\n\n  /**\n   * Return an object with a propertie key: value for each element in the storage.\n   */\n  toObject() {\n    let obj = {};\n    for (let ent of this) {\n      obj[ent[0]] = ent[1];\n    }\n    return obj;\n  }\n\n  /**\n   * Return a JSON string representing an object with a propertie key: value for each element in the storage.\n   */\n  toJSON() {\n    return JSON.stringify(this.toObject());\n  }\n\n  /**\n   * Return the numbers of elements in the storage\n   */\n  get length() {\n    return this.storageKeys.size;\n  }\n\n  /**\n   * Return the numbers of elements in the storage (alias for this.length)\n   */\n  get size() {\n    return this.length;\n  }\n\n  /**\n   * Add the key and the key's value to the storage, or update that key's value if it already exists\n   * \n   * @param {string} key the name of the key you want to create/update.\n   * @param {*} val the value you want to give the key you are creating/updating.\n   */\n  setItem(key, val) {\n    localStorage.setItem(`${this.options.name}_${key}`, JSON.stringify(val));\n    this.storageKeys.set(key.toString(), 1);\n    if (this.options.trigger) {\n      window.dispatchEvent(new Event(this.options.eventName));\n    }\n  }\n\n  /**\n   * Private method\n   */\n  _genKey() {\n    return 'uid_' + Math.random().toString(36).substring(2, 10);\n  }\n\n  /**\n   * Add the value with a random unique key to the storage.\n   * Return the key.\n   * \n   * @param {*} val the value you want to give the key you are creating/updating.\n   */\n  addItem(val) {\n    let key = this._genKey();\n    while (this.storageKeys.has(key.toString())) key = this._genKey();\n    this.setItem(key, val);    \n    return key;\n  }\n\n  /**\n   * Return the value of the key in the storage. If the key does not exist, null is returned.\n   * \n   * @param {string} key the name of the key you want to retrieve the value of.\n   */\n  getItem(key) {\n    let val = localStorage.getItem(`${this.options.name}_${key}`);\n    if (val == null) return null;\n    return JSON.parse(val);\n  }\n\n  /**\n   * Remove the key from the storage if it exists. If there is no item associated with the given key, this method will do nothing.\n   * \n   * @param {string} the name of the key you want to remove. \n   */\n  removeItem(key) {\n    localStorage.removeItem(`${this.options.name}_${key}`);\n    this.storageKeys.delete(key.toString());\n    if (this.options.trigger) {\n      window.dispatchEvent(new Event(this.options.eventName));\n    }\n  }\n\n  /**\n   * Clears all keys in the storage\n   */\n  clear() {\n    for (let key of this.keys()) {\n      localStorage.removeItem(`${this.options.name}_${key}`);    \n    }\n    this.storageKeys.clear();\n    if (this.options.trigger) {\n      window.dispatchEvent(new Event(this.options.eventName));\n    }\n  }\n\n}\n","import JsonStorage from './lib/JsonStorage'\n\n// Création d'un storage exprès pour les favoris\n// L'idée est d'utiliser l'id de la chanson en tant que clé de stockage. Comme elle est unique dans toute l'app,\n// pas de problème d'écrasement et cela permet de checker très facilement si une chanson est contenue ou non dans\n// le storage. Exemple: favoritesStorage.getItem(song.id)\nconst favoritesStorage = new JsonStorage({ name: 'favorites', eventName: 'favorites_updated' })\n\n// Cette fonction toggle une chanson au sein de la liste des favoris\nconst toggleFavorite = (song) => {\n  if(isInFavorite(song)) {\n    favoritesStorage.removeItem(song.id)\n  } else {\n    favoritesStorage.setItem(song.id, song)\n  }\n}\n\n// Vérifie si une chanson est dans les favoris (retourne l'entry si oui, undefined si non)\nconst isInFavorite = (song) => {\n  return favoritesStorage.getItem(song.id)\n}\n\n// Retourne la liste des favoris sous forme de tableau avec seulement la valeur (voir slides pour explication)\nconst getFavorites = () => {\n  return favoritesStorage.toArray().map((e) => e[1])\n}\n\nexport { toggleFavorite, isInFavorite, getFavorites }\n","import { getSongsForArtist, searchSongs } from '../api'\nimport playSong from './player'\nimport { getFavorites, toggleFavorite, isInFavorite } from '../favorites'\n\n// On obtient l'élément DOM qui nous servira de template pour un élément de la list\nconst songListItemTemplate = document.querySelector('#list-item-template')\n\n// Element DOM de la liste à manipuler\nconst songList = document.querySelector('.list')\n\nconst songSectionTitle = document.querySelector('#list-section h4')\n\n// Cette fonction s'occupe de modifier l'icone à l'intérieur de l'élément passé en paramètre,\n// selon si la chanson en deuxième paramètre est présente ou non\nconst toggleFavoriteIcon = (favoriteIcon, song) => {\n  if(isInFavorite(song)) {\n    favoriteIcon.innerText = 'playlist_remove' // ou favorite pour le coeur plein\n  } else {\n    favoriteIcon.innerText = 'playlist_add'  // ou favorite_border pour le coeur vide\n  }\n}\n\n// Génère le HTML nécessaire pour afficher une liste de chansons, basé sur le tableau passé en paramètre\nconst renderSongs = (songs) => {\n  // On vide la liste de ses anciennes informations, pour en ajouter de nouvelles à jour\n  songList.replaceChildren()\n\n  // On itère sur chacune des chansons récupérées depuis l'API pour cet artiste\n  songs.forEach((song) => {\n    // Créer une copie du template et de son contenu pour avoir un nouvelle élément vierge\n    // que l'on stock dans la variable newSongItem\n    const newSongItem = songListItemTemplate.content.cloneNode(true)\n\n    // On rempli le titre de la chanson dans ce nouvel élément, en sélectionnant l'élément\n    // list-item-title à l'intérieur (!dans newSongItem! Pas dans document)\n    newSongItem.querySelector('.list-item-title').innerHTML = song.title\n\n    // Au clique sur le bouton play, on transmet la chanson et le tableau duquel elle provient au player. Cela permet de\n    // lire la chanson et passer le contexte actuel au player (le tableau) pour faire précédent/suivant\n    newSongItem.querySelector('.play-button').addEventListener('click', () => {\n      playSong(song, songs)\n      window.location.hash = '#player'\n    })\n\n    // On récupère l'icone des favoris pour le modifier\n    const favoriteIcon = newSongItem.querySelector('.favorite-button .material-icons')\n\n    // Au clique sur le bouton favori, on toggle la chanson dans le storage et on ajuste son icone en fonction\n    newSongItem.querySelector('.favorite-button').addEventListener('click', () => {\n      toggleFavorite(song)\n      toggleFavoriteIcon(favoriteIcon, song) // on passe le target du click, à savoir l'icône\n    })\n\n    // A l'insertion, on met à jour l'icone, si la chanson est présente dans les favoris, afin d'avoir un icône\n    // correspondant à l'état de base\n    toggleFavoriteIcon(favoriteIcon, song)\n\n    // On l'ajoute à la liste de chansons\n    songList.append(newSongItem)\n  })\n}\n\n// Génère le HTML nécessaire pour afficher la liste de chanson d'un artiste, basé sur son id\nconst renderSongsForArtistSection = async (artistId) => {\n  // On récupère les songs d'un artiste depuis l'API, en se servant de son Id passé en paramètre\n  const songs = await getSongsForArtist(artistId)\n\n  // Set le nom de l'artiste\n  songSectionTitle.textContent = `Artistes > ${songs[0].artist.name}`\n\n  // Affiche les chansons\n  renderSongs(songs)\n}\n\n// Génère le HTML nécessaire pour afficher la liste de chanson d'un artiste, basé sur son id\nconst renderSongsForSearchSection = async (query) => {\n  // On récupère les songs correspondant à la recherche depuis l'API, en se servant de la query passée en paramètre\n  const songs = await searchSongs(query)\n\n  // Set le titre de la section\n  songSectionTitle.textContent = `Résultats pour \"${decodeURIComponent(query)}\"`\n\n  // Affiche les chansons\n  renderSongs(songs)\n}\n\n// Charge la section des chansons selon le tableau de favoris\nconst renderFavoritesSongsSection = () => {\n  // On récupère les songs présentent dans les favoris\n  const songs = getFavorites()\n\n  // Set le titre de la section\n  songSectionTitle.innerText = 'Favoris'\n\n  // Affiche les chansons\n  renderSongs(songs)\n}\n\nexport { renderSongsForArtistSection, renderSongsForSearchSection, renderFavoritesSongsSection }\n","// Il n'y a en fait pas de section recherche à proprement parler. Ce fichier sert juste à ajouter des listeners sur\n// le champ de recherche, premièrement pour l'afficher/le cacher, puis pour rediriger vers l'url de recherche, avec\n// la query. C'est le display section qui va gérer la logique du listing\n\n// Tags pour la recherche\nconst searchTrigger = document.querySelector('#search-trigger')\nconst searchInput = document.querySelector('#search-input')\n\n// Quand on click sur la loupe, on affiche le champ de recherche et on focus l'input\nsearchTrigger.addEventListener('click', () => {\n  searchInput.classList.add('active')\n  searchInput.focus()\n})\n\n// Lorsque l'utilisateur sort du champ de recherche, on le cache et on le vide\nsearchInput.addEventListener('blur', () => {\n  searchInput.classList.remove('active')\n  searchInput.value = ''\n})\n\n// Lorsque l'utilisateur entre quelque chose dans le champ, on redirige vers l'url #search-:query, où query est\n// la valeur du camp encodée. On encode la chaine de recherche pour éviter les caractères spéciaux\n// (typiquement, un '-' qui embêterait notre fonction displaySection)\nsearchInput.addEventListener('change', () => {\n  window.location.hash = `#search-${encodeURIComponent(searchInput.value)}`\n})\n","import renderArtists from './sections/artists'\nimport { renderSongsForArtistSection, renderSongsForSearchSection, renderFavoritesSongsSection } from './sections/songs'\n\n// On les importe au moins une fois dans l'index, pour être sûr que les eventlisteners seront appelés\nimport './sections/search_input'\n\n// S'occuper de \"toggler\" les liens dans la navigation\n// Désactiver le lien actif et activer le nouveau en bleu, selon l'url passée en paramètre de la fonction\nconst toggleNav = (hash) => {\n  // On va chercher le lien actuellement affiché (n'importe quel lien dans \"nav\" qui a une classe active) et en enlève\n  // la classe active\n  // NB: Noter le ? après le querySelector. Cela veut dire \"si on a trouvé quelque chose, on fait la suite, autrement rien\"\n  document.querySelector(`nav a.active`)?.classList.remove('active')\n  // On va chercher le lien avec pour url le href passé en argument et y ajouter la classe active pour le rendre bleu\n  // Exemple: <a href=\"#player\">...</a>\n  // NB: Noter le ? après le querySelector. Cela veut dire \"si on a trouvé quelque chose, on fait la suite, autrement rien\"\n  document.querySelector(`nav a[href=\"${hash}\"]`)?.classList.add('active')\n}\n\n// S'occuper de \"toggler\" les sections dans le body, en cachant la section actuellement affichée, puis en ajoutant\n// la classe active à la nouvelle pour l'afficher\nconst toggleSection = (hash) => {\n  // Comme pour le menu, on enlève la classe active à la section en cours\n  document.querySelector(`section.active`)?.classList.remove('active')\n  // et on essaie de trouver la section correspondante et l'afficher, en y ajoutant la classe active\n  document.querySelector(`${hash}-section`)?.classList.add('active')\n}\n\nconst displaySection = (hash) => {\n  if(hash == '') hash = '#home'\n\n  const hashSplit = hash.split('-')\n\n  // On appelle la fonction toggleNav qui va s'occuper de \"toggler\" les liens dans la navigation. On se sert toujours\n  // de la première partie de l'url (comme ça, si #artists-12 --> #artists est sélectionné)\n  toggleNav(hashSplit[0])\n\n  // On appelle la fonction toggleSection qui va s'occuper de \"toggler\" les sections dans le body. Par défaut, la première\n  // partie de l'url correspond à une section dans le HTML, par exemple -> #home --> #home-section. Dans certains cas,\n  // on va appeler cette fonction manuellement avec une valeur spécifique, pour afficher la section list, car l'url\n  // ne correspond pas\n  toggleSection(hashSplit[0])\n\n  switch(hashSplit[0]) {\n    case '#artists':\n      // S'il y a un paramètre derrière...? Ex: -> #artists-12 -> hashSplit[1] vaudra 12\n      if(hashSplit[1]){\n        // Cela nous permet d'afficher la section générique \"list\"\n        toggleSection('#list')\n\n        // On affiche la liste des chansons pour un artiste donné (d'après son ID reçu en paramètre)\n        renderSongsForArtistSection(hashSplit[1])\n      }\n      else {\n        // On affiche la liste des artistes\n        renderArtists()\n      }\n    break;\n\n    case '#search':\n      // Cela nous permet d'afficher la section générique \"list\"\n      toggleSection('#list')\n\n      // On affiche la liste des chansons pour le terme de recherche reçu en paramètre\n      renderSongsForSearchSection(hashSplit[1])\n    break;\n\n    case '#favorites':\n        // Cela nous permet d'afficher la section générique \"list\"\n      toggleSection('#list')\n\n      // On affiche la liste des chansons présentent dans les favoris\n      renderFavoritesSongsSection()\n    break;\n  }\n}\n\n// Ici, on écoute la mise à jour des favoris dans le storage. Lorsque la liste à changé et que l'on est dans la section\n// favoris, on remet à jour la liste pour enlever les éléments déselectionnés\nwindow.addEventListener('favorites_updated', () => {\n  if(window.location.hash == '#favorites')\n    renderFavoritesSongsSection()\n})\n\n// On link la fonction \"displaySection\" à l'événement hashchange pour être averti d'un changement de hash dans l'url\nwindow.addEventListener('hashchange', () => displaySection(window.location.hash))\n\n// Affichage au chargement pour traiter l'url en cours (exemple: on ouvre un lien dans un nouvel onglet)\ndisplaySection(window.location.hash)\n"],"names":["$96e14f2a7c3555e4$var$BASE_URL","async","$96e14f2a7c3555e4$var$loadJson","url","response","fetch","json","$96e14f2a7c3555e4$export$5f34afb258facb3","$96e14f2a7c3555e4$export$939cf8aa02e6e9c0","id","$96e14f2a7c3555e4$export$fd49fd7de453819a","query","encodeURIComponent","$e56b8ad525cbc6a1$var$artistListItemTemplate","document","querySelector","$e56b8ad525cbc6a1$var$artistList","$e56b8ad525cbc6a1$export$2e2bcd8739ae039","replaceChildren","forEach","artist","newArtistItem","content","cloneNode","href","innerHTML","name","src","image_url","append","$fb06cff0c0b5c1ad$export$2e2bcd8739ae039","timestamp","parseInt","hours","Math","floor","minutes","seconds","$d2a9a06f1479efe2$var$audioPlayer","$d2a9a06f1479efe2$var$playerThumbnail","$d2a9a06f1479efe2$var$playerSongTitle","$d2a9a06f1479efe2$var$playerArtistName","$d2a9a06f1479efe2$var$playerPrev","$d2a9a06f1479efe2$var$playerPlay","$d2a9a06f1479efe2$var$playerPlayIcon","$d2a9a06f1479efe2$var$playerNext","$d2a9a06f1479efe2$var$playerTimeCurrent","$d2a9a06f1479efe2$var$playerTimeDuration","$d2a9a06f1479efe2$var$playerProgress","$d2a9a06f1479efe2$var$logo","$d2a9a06f1479efe2$var$songList","$d2a9a06f1479efe2$var$currentSong","$d2a9a06f1479efe2$var$playSong","song","songs","audio_url","play","title","$d2a9a06f1479efe2$var$updateIcon","paused","classList","remove","add","addEventListener","pause","newIndex","indexOf","length","event","currentTime","currentTarget","value","max","duration","innerText","$d2a9a06f1479efe2$export$2e2bcd8739ae039","$6e0314840351d922$export$2e2bcd8739ae039","constructor","options","this","listen","trigger","eventName","_reloadKeys","window","evt","key","startsWith","dispatchEvent","Event","storageKeys","Object","keys","localStorage","filter","reduce","map","set","substring","Map","Symbol","iterator","entries","ind","values","k","getItem","callback","entrie","toArray","toObject","obj","ent","toJSON","JSON","stringify","size","setItem","val","toString","_genKey","random","addItem","has","parse","removeItem","delete","clear","$a0785e6c3841fb73$var$favoritesStorage","$a0785e6c3841fb73$export$7a53d9be8e9c5409","$a0785e6c3841fb73$export$569ebd4a31457497","$094e799a8fecf310$var$songListItemTemplate","$094e799a8fecf310$var$songList","$094e799a8fecf310$var$songSectionTitle","$094e799a8fecf310$var$toggleFavoriteIcon","favoriteIcon","$094e799a8fecf310$var$renderSongs","newSongItem","location","hash","$094e799a8fecf310$export$3b152bd728e163e7","artistId","textContent","$094e799a8fecf310$export$8c266e98d86d2877","decodeURIComponent","$094e799a8fecf310$export$47914d5bffde3db3","e","$f9b1f4c260254a3e$var$searchTrigger","$f9b1f4c260254a3e$var$searchInput","focus","$35da740d59af89ba$var$toggleSection","$35da740d59af89ba$var$displaySection","hashSplit","split","$35da740d59af89ba$var$toggleNav"],"version":3,"file":"index.5d0e2326.js.map"}